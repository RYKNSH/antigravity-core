# 開発原則（Development Principles）

> **このドキュメントはプロジェクトの最重要文書です。**
> すべての開発判断は、ここに記載された原則に基づいて行われます。

---

## 🎯 第一原理：First Principles Thinking

```
「問題を最も基本的な真実まで分解し、そこから論理的に再構築する」
— Elon Musk
```

### 実践方法

1. **問題に直面したとき**
   - 「なぜこれが起きているのか？」を5回繰り返す（5-Why）
   - 表面的な症状ではなく、根本原因を特定する
   - 既存の「常識」や「ベストプラクティス」を疑う

2. **解決策を設計するとき**
   - 制約を一旦無視して「理想の状態」を定義する
   - 理想から逆算して実装パスを設計する
   - 最もシンプルな解決策を選択する

3. **実装するとき**
   - 「なぜこのコードが必要か」を説明できること
   - 将来の自分が理解できるコードを書く
   - 過度な抽象化を避け、具体的に書く

---

## 🏆 理想系（Ideal State）駆動

### 定義
「理想系」とは、技術的・リソース的な制約が存在しないと仮定した場合の、
最も望ましいシステム状態を指します。

### 実践方法

```markdown
## 理想系の定義テンプレート

### 1. 現状の問題
[現在のシステムが抱える問題を具体的に記述]

### 2. 制約を無視した理想状態
[もし何の制約もなければ、どのような状態が理想か]

### 3. 現実の制約
[時間、リソース、技術的制約のリスト]

### 4. 実装パス
[理想に最も近づくための段階的アプローチ]
```

### なぜ理想系を定義するのか

- **北極星**: チームが向かうべき方向を明確にする
- **判断基準**: 「この変更は理想系に近づくか？」で判断できる
- **技術的負債の回避**: 理想から遠ざかる変更を検出できる

---

## 🔍 ボトルネック駆動開発

### 原則
```
「システムは最も遅い部分と同じ速度でしか動作しない」
— Theory of Constraints (TOC)
```

### 実践方法

1. **ボトルネックを特定する**
   - パフォーマンスプロファイリングを実施
   - ユーザーフィードバックを収集
   - システムメトリクスを監視

2. **ボトルネックに集中する**
   - ボトルネック以外の過度な最適化を避ける
   - 限られたリソースをボトルネック解消に投入

3. **ボトルネックを可視化する**
   - `docs/BOTTLENECK.md` に常に現在のボトルネックを記録
   - ボトルネックが解消されたら次を特定

### アンチパターン

- ❌ 「このコードが遅そうだから最適化しよう」（推測による最適化）
- ❌ 「念のためキャッシュを追加しよう」（不必要な複雑性）
- ❌ 「ベストプラクティスだからインデックスを追加」（思考停止）

---

## 🚫 アンチ・バンドエイド原則

### 禁止される行動

| 行動 | 理由 |
|------|------|
| 「とりあえず動く」修正 | 技術的負債の蓄積 |
| コメントで問題を隠す | 問題の先送り |
| テストなしの修正 | 回帰リスクの増大 |
| コピペによる重複 | 保守性の低下 |
| 例外を握りつぶす | デバッグ困難化 |

### 推奨される行動

| 行動 | 効果 |
|------|------|
| 根本原因の特定 | 真の解決 |
| 設計の見直し | 構造的改善 |
| リファクタリング時間の確保 | 長期的品質向上 |
| テストを先に書く | 仕様の明確化 |
| ペアプログラミング | 知識共有 |

### バンドエイド検出チェックリスト

変更をコミットする前に確認：

- [ ] この変更は根本原因を解決しているか？
- [ ] 同じ問題が他の場所で発生しないか？
- [ ] この変更なしで問題を解決する方法はないか？
- [ ] 6ヶ月後の自分がこのコードを理解できるか？
- [ ] テストでカバーされているか？

---

## 📊 判断フレームワーク

### 意思決定マトリクス

```
                    理想系に近づく
                         ↑
                         |
    避けるべき  ←--------+--------→  最優先で実施
                         |
                         ↓
                    理想系から遠ざかる
```

### 優先順位の決定

1. **MUST**: セキュリティ、データ整合性、法的要件
2. **SHOULD**: ユーザー価値、パフォーマンス、保守性
3. **COULD**: 開発者体験、将来の拡張性
4. **WON'T**: 現時点では不要、過度な最適化

---

## 🔄 継続的改善

### 定期レビュー

- **週次**: ボトルネックの確認と更新
- **月次**: 技術的負債の棚卸し
- **四半期**: 理想系の見直し

### フィードバックループ

```
実装 → 計測 → 学習 → 改善 → 実装 → ...
```

---

## 📚 参考資料

- [First Principles Thinking - fs.blog](https://fs.blog/first-principles/)
- [Theory of Constraints - Goldratt](https://www.toc-goldratt.com/)
- [Clean Code - Robert C. Martin](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)
