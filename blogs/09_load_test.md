# 自分を、攻撃する。


橋を完成させたら、
最初にやることを知っていますか。

壊しにいくんです。

大型トラックを何台も走らせて、
限界まで荷重をかけて、
壊れないか確かめる。

「荷重試験」というそうです。

完成したから終わり、じゃない。
壊れないと証明するまでは、仮設なんです。



前回、「見落としの話。」という記事を書きました。

自分でつくったものを自分でチェックすると、
「つくったときの記憶」が邪魔をして、
バグが見えなくなる。

それを「味見の限界」と呼びました。

あの話は、守りの話でした。
見落とさないために、チームをつくった。

今回は、攻めの話です。



先週、動画編集ツールの
大きなリファクタリングを終えました。

リファクタリングというのは、
機能は変えずに、内部の構造を整理すること。

部屋の模様替えみたいなものです。
家具の配置を変えるけど、
住む人の生活は変わらない。

10のフェーズに分けて、
9つの部品を入れ替えて、
11回の記録を残して、完了。

テストも通った。
コードの整形チェックも通った。
画面上でも、ちゃんと動いてる。

「完成だ」と思いました。



そこで、ひとつ実験をしました。

AIに「批判しろ」と命じたんです。

5人の専門家を仮想的に召喚して、
ぼくのコードを3ラウンドにわたって攻撃させる。

褒めるな。弱点を探せ。
根拠のない批判は禁止。
具体的に、数字と事実で壊しにこい。

そういうルールで。



結果、3つの問題が見つかりました。

ひとつ目が、いちばん衝撃的でした。

存在しないファイルから、
データを読み込もうとしていたんです。

「audio_features.py」というファイルを
使おうとしていたコードがあった。

でも、そのファイルは存在しない。
正しくは「audio.py」だった。

じゃあ、なぜ動いてたのか。

エラーが出ても、
それを握りつぶす仕組みになっていた。
プログラミングでは
「サイレントフェイル」と呼びます。

静かに失敗する。
壊れてるのに、壊れてないふりをする。

ぼくのテストでは、
この処理を通るパターンを試していなかった。
だから気づかなかった。

もし本番で、
音声ファイルつきの動画が処理されたら、
この機能だけ静かに死んでいたはずです。



ふたつ目は、速度の退行。

以前のコードでは、
音声の取り込みと文字起こしを
同時に処理していました。

並列処理、というやつです。
二人で別々の仕事を同時にやるイメージ。

ところが新しいコードでは、
これが一人ずつ順番になっていた。

リファクタリングのとき、
並列の仕組みを引き継ぎ忘れたんです。

機能は同じでも、遅くなっていた。



3つ目は、
データの保存方法に
ファイル破損のリスクがあったこと。

ファイルに書き込んで、
すぐ読み直して、
また書き込む。

この間にプロセスが止まったら、
データが中途半端な状態で残る。

1回の書き込みで済むのに、
2回やっていた。



この3つ、
ぜんぶぼくが書いたコードです。

テストして、チェックして、
「完成だ」と思ったあとに見つかったもの。

自分で見つけられたか、と聞かれたら、
正直、無理だったと思います。

なぜなら、ぼくには
「完成させた」という記憶があるから。

完成させたものを、
自分で壊しにいくのは難しい。

だから、他の目が必要だった。



ここで大事なことがあります。

前回の「味見の限界」は、
見落としを防ぐための話でした。

今回は、もう一歩踏み込んでいます。

味見は、「おいしいかどうか」の確認。
荷重試験は、「壊れないかどうか」の確認。

完成品にわざとストレスをかける。
壊しにいって、壊れなければ本物。

これは心理的にけっこうキツい。

自分がつくったものを、
「ダメだろ」という目で見される。

でも、壊れたおかげで、直せた。

壊れなかったら、
本番で壊れていたかもしれない。



もし今、
「完成した」と思っているものがあるなら。

それを壊しにいってみてください。

友人に「ここ、おかしくない？」と聞いてみる。
AIに「批判しろ」と命じてみる。

壊れるかもしれない。
でも、直せる。

壊れないかもしれない。
そしたら、本物だとわかる。



完成は、ゴールじゃないんです。

完成は、荷重試験の始まりなんです。

