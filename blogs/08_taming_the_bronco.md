# じゃじゃ馬を飼い慣らす話。


何かをつくるとき、
最初の選択が、最後の苦しみを決める。

これ、プログラミングに限らない話なんです。


ぼくはいま、動画編集ツールをつくっています。

ひとりで。

動画をアップロードしたら、AIが自動で分析して、
ショート動画の候補をつくってくれる。
テロップもつけてくれるし、テンプレートも選べる。
承認ボタンを押したら、レンダリングが走って、ダウンロードできる。
レンダリングというのは、編集した内容を最終的な動画ファイルに焼き上げる工程のこと。
料理で言えば、仕込みが終わって、オーブンに入れる段階です。

聞くだけなら、すごくシンプルでしょう？

ところが、
このツールが、ものすごいじゃじゃ馬なんです。



先週、ダウンロードした動画を見て愕然としました。

テンプレートを選んだのに、適用されてない。
テロップのスタイルを設定したのに、反映されてない。
承認したはずの設定が、どこかで消えてる。

3つのバグがあった。

ひとつは、設定データの受け渡し漏れ。
もうひとつは、処理の二重実行。
みっつめは、URLのハードコーディング。
ハードコーディングというのは、本来は設定ファイルにまとめるべき値を、
コードの中にベタ書きしてしまうこと。
住所を手帳に書かず、あちこちのメモに走り書きしているようなものです。

ぜんぶ、別々の場所で、別々の原因で起きてた。

1個直すと、別の場所が壊れる。
3歩進んで2歩下がる。
いや、3歩進んで2.5歩下がる感じ。

これ、バグの問題じゃないんですよ。
設計の問題なんです。



建築に例えると、わかりやすいかもしれません。

家をつくるとき、
まず基礎を打つでしょう。

基礎がしっかりしていれば、
2階を増築しても、屋根裏をつくっても、大丈夫。

でも、基礎を打たずに建て始めたらどうなるか。

最初の1部屋は、問題なく建つんです。
2部屋目も、ちょっと工夫すれば建つ。
でも3部屋目を建てようとしたとき、
1部屋目の壁がミシッて言う。

ぼくのツールは、まさにこれでした。

レンダリングを担当するファイルが1849行。
画面の表示を担当するファイルが1592行。
指揮者役のファイルが602行。

1つのファイルに、何もかも詰め込んでいた。
基礎を打たずに、部屋を増築し続けていた。



この問題には名前があります。

「泥団子」。

英語ではBig Ball of Mudと呼ばれていて、
つまり、全部が全部にくっついている状態。

ひとつの変更が、予想もしない場所に波及する。

レンダリングのコードの中に、
FFmpegの直接呼び出しが50箇所もあった。
FFmpegというのは、動画を加工するための道具で、
いわばプロの調理器具のようなものです。

そしてsubprocess.runは、プログラムが外部の道具を呼び出すための命令。
つまり「FFmpegさん、この動画を切ってください」と頼む手紙みたいなもの。

その手紙が、50箇所にバラバラに書かれている。
もしFFmpegのバージョンが変わったら、
50通の手紙をぜんぶ書き直さなきゃいけない。

APIのURLが7つのファイルにハードコーディングされていた。
開発環境と本番環境を切り替えるたびに、
7つのファイルを手作業で書き換える。
1つでも忘れたら、動かない。

プロジェクトのルートに、作業中に溜まったファイルが259個。

動作記録、いわゆるログファイル。
自動化した手順書、エンジニアはこれをシェルスクリプトと呼びます。
そして「いま誰が動いてるか」を示すPIDファイル、つまりプロセスの名札のようなもの。

どれが必要で、どれがゴミか、もう誰にもわからない。



じゃあ、どうつくるべきだったのか。

これ、後から振り返ると、恥ずかしいくらいシンプルなんです。



まず、役割を分ける。

料理で言えば、仕込みと調理と盛り付けを、
同じまな板でやらない、ということ。

動画を分析する部分、レンダリングする部分、
画面を表示する部分、データを保存する部分。
それぞれを、独立した部品にする。

ひとつの部品は、ひとつのことだけやる。
部品同士は、決められた窓口だけで会話する。

エンジニアの世界では、
これを「関心の分離」と呼びます。

当たり前のことなんです。
でも、急いでいるとき、ひとりで開発しているとき、
「あとで整理しよう」って思って、やらないんですよ。



次に、約束事をつくる。

部品と部品のあいだを流れるデータには、
必ず「型」をつける。

「この部品に渡すデータには、
必ずこの項目が入っている」
という約束を、コードで明文化する。

ぼくのツールでは、
テロップの設定データを渡すとき、
caption_configというパラメータを設計図に含めていた。
設計図自体にはちゃんと定義されている。

でも、指揮者役のコードが設計図をつくるとき、
このパラメータを渡し忘れていた。

設計図には場所があるのに、
そこに何も書かなかった。

結果、レンダリングのコードは
「テロップの設定がない」と判断して、
テロップをまるごとスキップした。

これ、約束事を強制する仕組みがあれば、
起きなかったバグなんです。

「このパラメータは必須」とコードに書いておけば、
コンパイルの時点でエラーを出してくれる。
実行する前に気づける。



そして、設定は1箇所にまとめる。

URLも、パスも、環境変数も。
ぜんぶ1つのファイルに書いて、
そこだけ見ればすべてが分かるようにする。

7つのファイルに散らばったURLを、
定数ファイルに集約した。
たったこれだけのことで、
「開発環境で動くのに本番で動かない」がゼロになる。



最後に、テストを先に書く。

テストがないコードは、
ブレーキのない車と同じです。

新しい機能を足すたびに、
「古い機能が壊れてないか」を確認できる仕組みがないと、
増築するたびに1部屋目の壁がミシッて言う。



こうやって書き出すと、
全部「当たり前のこと」なんですよね。

でも、当たり前のことを当たり前にやるのが、
いちばん難しいんです。

とくにひとりのときは。

チームなら「そこ、分けたほうがよくない？」って
誰かが言ってくれる。

でもひとりだと、
自分の書いたコードに「違和感」を感じにくい。

料理の味見と、同じ構造です。



ぼくが学んだのは、
速さと丁寧さのバランスの話じゃなかったんです。

「最初に基礎を打つ時間」は、
「あとでバグを直す時間」の10分の1だった。

数字で言うと、
テロップの設定漏れを見つけるのに6時間かかった。

もし最初から「caption_configは必須パラメータ」と
設計図に明記していたら、
その6時間はゼロだったんです。

速くつくりたいから、基礎を飛ばす。
でも結果的に、基礎を飛ばしたほうが遅くなる。

これ、物理学の法則みたいなもので、
避けようがないんですよね。



もし今、何かをつくっていて、
「動くけど、触るたびに壊れる」
って感じているなら。

それ、能力の問題じゃないです。
基礎の問題です。

じゃじゃ馬は、
最初に手綱をしっかり握っていれば、
ちゃんと走ってくれるんです。

でも、走り出してから手綱を探すと、暴れる。

基礎は、手綱です。



ひとりでつくっている人へ。

「速くつくる」と「雑につくる」は、
ちがいます。

速くていい。
でも、基礎だけは丁寧に。

1849行のファイルは、
最初から5つに分けておけばよかった。

50箇所のsubprocess.runは、
最初から1つのラッパーにしておけばよかった。
ラッパーというのは「包み紙」のことで、
同じ作業をまとめて1箇所で管理する仕組み。
50通の手紙を、1つの窓口から出すようにする、ということ。

7つのハードコーディングは、
最初から定数ファイルにしておけばよかった。

ぜんぶ、後から分かることです。
でも、知っていれば最初からできることでもある。

だから、この話を書きました。



じゃじゃ馬は、嫌いじゃないんです。

でも次は、
最初から手綱を握ってから、走り出そうと思います。
