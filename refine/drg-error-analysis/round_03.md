# Round 3: 対処戦略の構造化 — 防止/検知/回復の3層防御

**日時**: 2026-02-27T14:17:00+09:00
**前ラウンドからの焦点**: 48エラー全てに対する対処方針の策定

---

### 🔄 Round 3: 構造的対処フレームワーク

**🏛️ Fault Architect**: 48個のエラーを1つずつ対処するのは非効率。**パターン別に構造的に防御する**。対処は3層：

| 層 | 意味 | タイミング |
|----|------|-----------|
| 🛡️ **Prevent** | そもそも起こらない設計にする | ビルド時/設計時 |
| 🔍 **Detect** | 起きたら即座に検知する | ランタイム |
| 🔄 **Recover** | 検知後に自動または手動で復旧する | 障害後 |

---

#### Guard 1: DRGファイル保護（E1.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G1.1**: DRG書き込み時にアトミック操作（tmp書き込み → rename） | E1.1, E5.5 | 🛡️ Prevent |
| **G1.2**: 書き込み前にJSON.parse検証 | E1.1 | 🛡️ Prevent |
| **G1.3**: スキーマバリデーション（必須フィールドチェック） | E1.2 | 🛡️ Prevent |
| **G1.4**: エッジ整合性チェック（参照先ノードの存在確認） | E1.3 | 🔍 Detect |
| **G1.5**: 循環検出（DFS）を更新時に実行 | E1.4 | 🔍 Detect |
| **G1.6**: ファイルロック（flock）でシングルライター保証 | E1.5, E7.4 | 🛡️ Prevent |
| **G1.7**: 毎セッション開始時にバックアップ生成（`data_graph.backup.json`）| E1.7, E3.5 | 🔄 Recover |
| **G1.8**: git管理 + `.gitignore`に入れない明示的ルール | E1.7 | 🔄 Recover |

#### Guard 2: MCP接続保護（E2.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G2.1**: 全MCPに30秒タイムアウト設定 | E2.1, E4.5 | 🛡️ Prevent |
| **G2.2**: OAuth2自動リフレッシュ + 失敗時にSlack/Discord通知 | E2.2, S2 | 🔍 Detect |
| **G2.3**: レート制限対応（exponential backoff + ページネーション） | E2.3, S6 | 🛡️ Prevent |
| **G2.4**: MCP応答のスキーマ検証（期待するフィールドが存在するか） | E2.4, E2.6 | 🔍 Detect |
| **G2.5**: 各MCP独立フォールバック（1つ死んでも他は動く） | E2.5 | 🛡️ Prevent |
| **G2.6**: **Canary Check** — 既知データの読み取りテスト | S1 | 🔍 Detect |

> **G2.6 は S1（サイレント腐敗）への最重要対策**。セッション開始時に「Notionの特定ページが読めるか」「GitHubの特定リポジトリが見えるか」を**既知の正解**と照合する。読めなければ「権限縮小」を検知。

#### Guard 3: memory/保護（E3.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G3.1**: decisions.jsonのTTL強制（90日超のエントリを自動削除） | E3.1 | 🛡️ Prevent |
| **G3.2**: 判断記録に「コンテキスト条件」を必須フィールドとして含める | E3.2, S4 | 🛡️ Prevent |
| **G3.3**: patterns.jsonにconfidence_scoreと使用回数を付与、低スコアは自動減衰 | E3.3 | 🛡️ Prevent |
| **G3.4**: memory/は**ローカル専用、.gitignore必須** | E8.1 | 🛡️ Prevent |

#### Guard 4: セッション開始プロトコル保護（E4.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G4.1**: /go ワークフローにDRG読み込みをハードコード（スキップ不可） | E4.1 | 🛡️ Prevent |
| **G4.2**: DRGの`last_synced`タイムスタンプと現在時刻の差分チェック | E4.2 | 🔍 Detect |
| **G4.3**: Canary Check（G2.6）をプロトコルに統合 | E4.4 | 🔍 Detect |
| **G4.4**: プロトコル実行時間の上限60秒、超過時は部分ロードで進行 | E4.5 | 🛡️ Prevent |

#### Guard 5: 自動同期保護（E5.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G5.1**: SECRETARY BUDDYのヘルスチェック（PID監視 + 自動再起動） | E5.1 | 🔄 Recover |
| **G5.2**: イベントにタイムスタンプ付与、処理時にタイムスタンプ順に並び替え | E5.2 | 🛡️ Prevent |
| **G5.3**: イベントIDによるdedup（同一IDは処理済みフラグで無視） | E5.3 | 🛡️ Prevent |
| **G5.4**: DRG更新はアトミック操作（G1.1と同一） | E5.5 | 🛡️ Prevent |

#### Guard 6: 相関検出保護（E6.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G6.1**: L1マッチにminimum token lengthフィルタ（2文字以下の名前一致は無視） | E6.1 | 🛡️ Prevent |
| **G6.2**: 日本語/英語の正規化マッピングテーブル | E6.2 | 🛡️ Prevent |
| **G6.3**: L3（AI推論）の結果にconfidence_score必須、0.7未満は「候補」表示のみ | E6.3 | 🔍 Detect |
| **G6.4**: 相関エッジにTTL（180日）、未アクセスなら自動減衰 | E6.4 | 🛡️ Prevent |

#### Guard 7: 運用保護（E7.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G7.1**: セッション開始時にDRG vs 実データの整合性差分チェック（サンプリング） | E7.1, E7.2 | 🔍 Detect |
| **G7.2**: SSD接続状態チェック（`/Volumes/PortableSSD`のマウント確認） | E7.3 | 🔍 Detect |
| **G7.3**: DRGファイルにflock（G1.6と統合） | E7.4 | 🛡️ Prevent |
| **G7.4**: `data_graph.json`のgitマージ時は「手動解決」ルール（auto-mergeしない） | E7.5 | 🛡️ Prevent |

#### Guard 8: セキュリティ保護（E8.x対策）

| 対策 | 対象エラー | 層 |
|------|-----------|-----|
| **G8.1**: memory/は.gitignore必須（G3.4と統合） | E8.1 | 🛡️ Prevent |
| **G8.2**: DRGにPII（個人名・メアド等）を格納禁止。IDのみ保持 | E8.2, E8.3 | 🛡️ Prevent |
| **G8.3**: 相関検出L3の推論結果に「人間関係の推測」を禁止するルール | E8.4 | 🛡️ Prevent |
| **G8.4**: git push前のpre-commitフックでPIIスキャン | E8.2 | 🔍 Detect |

---

**🤔 Skeptic**: 32のGuardが出た。だが1つ懸念がある — **Guard自体のエラーはどうする？** G2.6（Canary Check）自体が壊れたら、S1（サイレント腐敗）は検知できない。防御の防御は無限ループになる。どこかで「ここまでは信頼する」の線引きが必要だ。

**⚡ Chaos Engineer**: Skepticの指摘は正しい。**信頼境界（Trust Boundary）** を明示する：

| レイヤー | 信頼する | 信頼しない |
|---------|---------|-----------|
| OS / ファイルシステム | ✅ macOSは正しく動く | ❌ ディスク破損は起こりうる |
| JSON.parse | ✅ 正しくパースする | ❌ 入力データは信頼しない |
| MCP SDKの接続確立 | ✅ 接続成功=本当に接続してる | ❌ データの正しさは保証しない |
| AIの推論 | ❌ 常に疑う | — |

**😈 Devil's Advocate**: 最後に1つ。全ての技術的Guardを実装しても、**最大のリスクは「実装しない」** だ。32のGuardを全部書くのは膨大な工数。優先順位を付けなければ、結局何も実装されずに終わる。

---

### 🧭 Moderator Review

| 項目 | 内容 |
|------|------|
| 明確になったこと | 32のGuard（防止22件/検知8件/回復2件）で48エラーをカバー。信頼境界を明示。S1対策のCanary Checkが最重要 |
| まだ残る懸念・論点 | Guard実装の優先順位、Guard自体のテスタビリティ |
| 次ラウンドの焦点 | 実装優先度のティアリング（Must/Should/Could）|
| **判定** | `Continue` |
| **判定根拠** | 優先順位なきGuardリストは実行不能。構造的に解決されたとは言えない（MR-03） |
