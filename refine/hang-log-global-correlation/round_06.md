# Round 6: 「CoreサーバーサイドOSS + ローカル自律更新アーキテクチャ」

**日時**: 2026-02-24T11:19:00+09:00
**前ラウンドからの焦点**: 依存グラフの不在・承認ゲート・Chaos層統合
**今回の命題（ユーザー提起）**: Coreをサーバーサイドで自己改善ループさせ、ローカルはgit pullで最適解のみを受け取る。Core側は依存マップ上の全ファイルをあらゆるテストで検証してからmainにマージ。

---

## 議論

**🤔 Skeptic**:
「"全セッションからのデータを拾う" というが、セッションデータはどこにあるか。

現状、各ユーザーの `brain_log` は `~/.antigravity-private/` または `~/.gemini/antigravity/` にある——つまりサーバーには届いていない。プライベートリポジトリにさえない。

サーバーサイドが拾えるのは `antigravity-core`（public）にpushされたもの——`incidents.md`, `safe-commands.md` の変更履歴——のみだ。

"全セッションからのデータ" が自動収集されるためには、**ユーザーがbrain_logのどの部分をCore-A（public）に昇格させるかを判断する仕組み**が必要になる。

なければサーバーサイドのループは "pushされたもの" しか学習できず、実践ハングの大半（Core-Bにしか記録されないもの）はスコープ外に残る。"全セッション" という前提が成立しない。」

---

**😈 Devil's Advocate**:
「ユーザーの提案は本質的に **"GitHubをCIとして使うAIワークフローエンジンの自律改善CI"** だ。

GitHub ActionsでCoreを自律テスト・マージするとき、**誰がテストを書くか**という問題が発生する。AIがAIのテストを書くなら、品質を保証するのは誰か？

さらに——**"あらゆるテストを通してから" のあらゆるテストが実はChaos層だ**とRound 5で結論が出た。サーバーサイドでChaos Engineeringを動かすということは、意図的にネットワーク断・ファイルロック・プロセスハングをサーバー上で誘発するということだ。

**専用のサンドボックス環境**が必要になる。インフラコストを生む。OSSプロジェクトのCoreがそれを無制限に回すとすると、誰がその計算リソースを持つのか。」

---

**🔬 Systems Analyst**:
「このアーキテクチャを構造として図式化する。

```
[全ユーザーのローカル]
  sessions → incidents.md, safe-commands.md変更 → git push → antigravity-core (public)
                                   ↓
[サーバーサイド Core自律ループ]
  PR自動生成 ← AI改善提案エンジン
  ↓
  CI: 依存マップスキャン + Chaos層テスト + 単体テスト
  ↓
  Pass → main merge
  ↓
[各ユーザーローカル]
  checkin.md のSLOW ZONE: git pull origin main → 最新Coreを受け取る
```

既に実現されている部分とギャップ：

| コンポーネント | 現状 | ギャップ |
|---|---|---|
| ユーザー → Core push | ✅ git push 済み | 自動化が課題 |
| AI改善提案エンジン | 🔶 `/evolve` スクリプトが存在 | サーバーで動かすインフラなし |
| 依存マップ | ❌ 未定義 | Round 5で確認 |
| CI (Chaos + Unit) | ❌ GitHub Actionsなし | `chaos_monkey.js` 孤立 |
| ローカル自動pull | ✅ checkin.mdのSLOW ZONEで実行中 | 問題なし |

**欠けているのは "Core内部の自律改善エンジン" のみ。依存マップとGitHub Actions最小CIの2点が最初のギャップ。**」

---

**🧠 Root Cause Hunter**:
「このアーキテクチャが実現した世界で、何が "閉じる" のかを検証する。

| 問題 | このアーキテクチャで解決するか |
|---|---|
| 学習ループが閉じない（brain_log揮発） | **△**：pushされた知識は永続化。Core-B内データは依然揮発 |
| watchdogがインシデントを隠蔽 | **✅**：Chaos層CIがサーバー側でハングを再現→検出→修正をループ |
| 2Coreの未文書化 | **✅**：依存マップがあれば自然に解消 |
| brain_log → incidents.md 転記トリガー不在 | **✅**：checkin.mdのスキャンロジックがCore更新で強化可能 |
| 承認ゲートなしの自動修正リスク | **✅**：PR経由のマージがゲートになる |
| 実践ハングとテストのギャップ | **✅**：Chaos層CIが架け橋 |

根本命題を更新する：

> **旧命題（Round 3）**: 「Antigravityは高度なハング対策を持ちながら、そのハング対策がインシデントを隠蔽し学習ループを閉じえないという逆説的な構造を持っている」

> **新命題（Round 6）**: 「Antigravityの学習ループは、CoreをサーバーサイドCIとして自律運転させることで初めて閉じる。ローカルは "消費者"、Coreは "自律進化する知識エンジン" という役割分担が本来の設計ゴールだ」」

---

## 🧭 Moderator Summary（Round 6）

| 項目 | 内容 |
|------|------|
| **構造的発見** | ローカル→Core→ローカルのフローは既に半分動いている。欠けているのは "Core内部の自律改善エンジン（CI + 依存マップ）" だけ |
| **新たな制約** | ①Chaos CIはサンドボックスが必要（インフラコスト）②サーバーが学習できるのは "pushされた知識" のみ（Core-Bは依然揮発）③テストを書く主体の問題 |
| **命題の更新** | AntigravityのゴールはCore = 自律進化する知識エンジン / ローカル = 消費者 という役割分担 |
| **実装優先度（仮）** | 1. 依存マップ（JSON形式でWF間の読み書き定義）→ 2. GitHub Actions最小CI → 3. Chaos層（サンドボックス確保後） |
| **判定** | `Conclude` — 5ラウンドを経て根本アーキテクチャが定式化された。次は `/whitepaper` でビジョン文書化、または `/go` で依存マップ実装から着手 |
