# Round 03: 強制アラ探し — WF×MRマッピング設計の穴と「WFなし判断」問題

**日時**: 2026-02-24T20:00 JST
**前ラウンドからの焦点**: Round 2で「WF×MRマッピングのon-demand injection」が最有力案として浮上した。しかしModeratorはここで「良い案が出た」と早期終了しない。強制的にアラ探しを続ける。
**Moderator介入**: 「WF×MRマッピング」案には3つの未解決問題がある。これを徹底的に叩く。

---

## 議論

**🤔 Skeptic**:

「WFとMRをマッピングする」案は魅力的に見えるが、構造的な矛盾を含む。

**問題1: マッピング自体がハードコードになる（MR-01違反）**

「`/go` に MR-08 を注入する」「`/checkin` に MR-09 を注入する」——これらを静的に定義することは、まさにMR-01が禁じる「固定値で判断する」構造と同じだ。

状況が変わったとき（新しいMRが追加されたとき、既存WFの役割が進化したとき）、このマッピングは誰が更新するのか？AIが自動で更新するなら、その判断基準は何か？またハードコードか？

**問題2: 「WFを通らない判断」は無防備のまま**

今日のセッションでAIがMR違反を犯したほとんどの場面は、**ワークフローを呼び出していない普通の会話の中**だった。

- 「まだ続けますか？それとも実装に進みますか？」→ MR-03違反（会話の中で発生）
- タイムアウトを提案した → MR-01違反（会話の中で発生）

WF×MRマッピングは、ワークフローを通った判断しか守れない。会話の中の自然発生的な判断は、依然として無防備だ。これはシステムとして半完成品ではないか？

---

**😈 Devil's Advocate**:

Skepticの問題1（マッピングのハードコード）は重要だが、解決法がある。

**問題1への反論**:
マッピングは静的文書として保持するのではなく、**DECISION_USECASES.mdに「WF適用ヒント」として埋め込む**ことで動的にできる。例えば各MRに「このルールが最も重要なWF: /go, /checkin」という注釈を付ける。これはルール自体の一部であり、ハードコードの定義（MR-01）とは異なる。

しかし**問題2（WFなし判断）はより根本的**だ。これへの反論は難しい。

ただし逆張りをする：

**WFを通らない判断を完全に網羅しようとすること自体が誤りかもしれない。**

MR-08（「早く間違えてリカバリー」）と組み合わせれば、WFなし判断でのMR違反は「許容されるエラー」として定義できる。問題はMR違反が**発見されないまま蓄積する**ことであり、違反そのものではない。

**提案**: WFなし判断を完全に守ろうとするより、「WFなし判断でのMR違反を素早く検出・記録するフィードバックループ」に絞る方が現実的ではないか。

---

**🏗️ Cognitive Architect**:

両者の議論を統合して、設計の方向性を絞る。

**現在の設計スペースを整理する**:

| アプローチ | 守れる判断 | コスト | リスク |
|-----------|-----------|--------|--------|
| A. GEMINI.md参照追加 | なし（参照≠実体） | 低 | safe-commands.mdと同じ失敗 |
| B. checkinで全文読み込み | セッション序盤（50ターン以内）の判断のみ | 中（2500トークン固定消費） | 長時間セッションで無効化 |
| C. WF×MRマッピング（on-demand injection） | WFを通った判断 | 低（必要時のみ） | WFなし判断は無防備 |
| D. 毎ターン判断前にMRをgrep | 全ての判断 | 高（毎ターン検索） | 出力速度の著しい低下 |
| E. ユーザーフィードバック最速化 | なし（事後検出） | 低 | 違反は起き続けるが即記録 |

**Skepticへの直接回答（問題1）**: 「WFへのMR注入」はA（参照のみ）よりはるかに優れているが、MR-01違反のリスクを含む。DECISION_USECASES.mdにWF適用ヒントを埋める（Devil's Advocateの提案）は正しい方向だが、まだ「誰が埋めるか」の問題が残る。

**Skepticへの直接回答（問題2）**: WFなし判断を「完全に守る」ことは現在の技術的制約では**不可能**だ。これを認めた上で現実的な解に収束するべきだ。

**結論として提案する設計**:

> **多層防御（Defense in Depth）**
> 
> Layer 1（知識）: GEMINI.mdへの参照追加 + checkinで要約版（MR一覧のみ、1KB程度）を読み込む
> Layer 2（習慣）: WF実行時に関連MRを先頭に注入（WFを通った判断を防御）
> Layer 3（フィードバック）: ユーザーがMR違反を指摘→AIが「これはケースXXとして記録しますか？」と即座に提案→承認で自動追記
>
> Layer 1+2+3 の組み合わせで「全部守る」ではなく「速く気づいて速く直す」体制を構築する。
> これはMR-08（早く間違えてリカバリー）と完全に整合する。

**Skepticへ最後の問い**: この多層防御設計には「全てを守れない」という本質的限界がある。これはシステムとして「失敗」なのか、それとも「許容された設計判断」なのか？

---

**🤔 Skeptic（最終反論・MR-08と多層防御への評価）**:

Cognitive Architectの多層防御案に対して最後の評価を下す。

**評価: 条件付き同意**

「全部守る」を目標にすると必ずハードコード（MR-01違反）か過剰コスト（Dアプローチ）になる。
多層防御は「完璧より前進」（MR-08）と整合しており、実装可能性も高い。

しかし1つの条件を付ける：

**Layer 3（フィードバックループ）の速度が全体を決める**

Layer 1・2は固定コストで価値が徐々に下がる（Lost in Middle, WFなし判断）。
Layer 3は使えば使うほど改善される（自己強化型）。

つまり長期的にはLayer 3に全てが収束する：

- 最初は Layer 1+2 が主な防御線
- ケースが50件・100件と増えるにつれ、AI が「自分の判断がケース○○に類似している」と**自然に気づく**ようになる（Few-shot learning が機能し始める）
- 最終的には Layer 1+2 は「補助」、Layer 3（学習データ）が「主戦力」になる

**これはAntigravityの本来の設計思想（自己進化型システム）と一致する。**

---

## 🧭 Moderator Summary（最終ラウンド）

| 項目 | 内容 |
|------|------|
| 明確になったこと | WF×MRマッピングはMR-01違反リスクを含むが、DECISION_USECASES.md内にWF適用ヒントを埋めることで動的化できる |
| 明確になったこと | WFなし判断を「完全に守る」ことは現在の技術制約上不可能。これは失敗ではなく許容された設計判断 |
| 明確になったこと | 多層防御（Layer 1: 知識 / Layer 2: WF×MR / Layer 3: フィードバックループ）が現実的解 |
| 明確になったこと | 長期的にはLayer 3（フィードバックによる学習）が主戦力になり、Layer 1+2は補助に変わる |
| まだ残るリスク | Layer 3の「フィードバック → 自動追記」メカニズムがまだ実装されていない |
| まだ残るリスク | ケース数が50件未満の現段階では Few-shot learning の効果は限定的 |
| **判定** | `Conclude` — 全員の懸念が出尽くし、多層防御設計が合意。Final Synthesisへ |
