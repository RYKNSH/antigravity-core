# Portable Studio: Troubleshooting Guide

## 外付け SSD 環境でのビルドエラー

### 問題: UTF-8 読み込みパニック
- **事象**: `pnpm tauri build` または `pnpm tauri dev` 中に `failed to read file '.../._default.json': stream did not contain valid UTF-8` や `failed to define permissions for core:path... stream did not contain valid UTF-8` のようなパニックでビルドが失敗する。
- **原因**: macOS が作成するリソースフォーク (`._` で始まる AppleDouble ファイル) が、Tauri v2 の機能（Permissions/Capabilities）自動スキャン対象ディレクトリに混入し、Rust 側のメタデータ解析エンジンがこれらを正当な設定ファイルとして読み込もうとしてパニックを起こすため。

### 解決策

#### 1. リソースフォークの削除とビルドキャッシュのクリア
ビルド前に `src-tauri` および `target` 内の `._` ファイルを削除する。また、依存関係の不整合を防ぐためにキャッシュをクリアする。

```bash
# リソースフォークの削除
find . -name "._*" -delete

# Rust キャッシュのクリア (src-tauri ディレクトリで実行)
cargo clean
```

**注意**: `target` 内部に `._*` ファイルが存在する場合、`cargo clean` 自体が `No such file or directory (os error 2)` や `failed to remove file` といったエラーで失敗することがある。その場合は、手動で `target` ディレクトリを完全に削除してから再ビルドを行う。
```bash
rm -rf src-tauri/target
```

 #### 2. ビルドターゲットディレクトリの変更 (最も確実)
外付け SSD 上でビルドを行う際、Tauri v2 の機能スキャン中に一時ファイルが生成され、macOS が即座に `._` メタデータを付与します。このため、ビルド直前に `find` で削除しても、ビルドプロセスの中で「削除 ➔ 再生成 ➔ 読み込みパニック」のループに陥ることがあります。

コンパイル成果物を **Mac 本体のローカルディレクトリ (APFS形式)** に出力することが、この問題を回避する最も確実な方法です。

```bash
# 一時ディレクトリを作成し、CARGO_TARGET_DIR をそこに指定してビルド
mkdir -p ~/.tmp_build/portable-studio
CARGO_TARGET_DIR=~/.tmp_build/portable-studio pnpm tauri build
```
これにより、ファイルシステム起因のパニックを回避できるだけでなく、ExFAT の低速な I/O を避けられるため、ビルド速度が劇的に向上します。生成された `.app` や `.dmg` は指定したディレクトリ内の `release/bundle/` 配下に出力されます。

---

## UI & ウィンドウの問題
 
 ### 透過ウィンドウでボタンがクリックできない
 - **事象**: ポモドーロタイマーのポップアウトウィンドウにおいて、ボタンや閉じるアイコンが全く反応しない。
 - **原因**: Tauri の `WebviewWindow` 設定で `transparent: true` を有効にしている場合、透過部分のクリックイベントが背後のウィンドウに透過してしまい、かつルート要素全体に `data-tauri-drag-region` を設定しているとドラッグイベントが優先されてボタンのクリックが無視されるため。
 - **解決策**:
     1. ウィンドウの設定で `transparent: false` に変更する（クリックの確実な捕捉）。
     2. `data-tauri-drag-region` を、ボタン以外のタイトルバー相当の領域のみに適用するように JSX を修正する。
     3. 視認性と操作性のバランスを取るため、ウィンドウサイズを適切に（例：220x140 ➔ 240x160）拡大する。

 ### ポップアウトウィンドウで音が鳴らない
 - **事象**: タイマー終了時や操作時にオーディオ（AudioContext）が機能しない。
 - **原因**: モダンブラウザ（Webview）の自動再生ポリシーにより、ユーザーによる直接のインタラクション（クリック等）がない状態では `AudioContext` の作成や再開が制限されるため。
 - **解決策**:
     1. タイマー開始ボタン（Play）などのユーザー操作イベント内で `AudioContext` を初期化または `resume()` する処理を実装する。
     2. `useRef` で `AudioContext` を保持し、必要に応じて一貫したインスタンスを再利用する。

 ### タスクや KPI の並べ替え（Drag & Drop）が反映されない
 - **事象**: ドラッグ&ドロップ操作を行っても、要素の順番が変わらない、または挙動が不安定。
 - **原因**: 
     1. **Native DnD の不安定さ**: HTML5 Drag and Drop API は、React 19 や Vite の HMR 環境下において、ステート同期とイベント発火のタイミングが非常に過敏であり、特にインデックス管理 (`draggedTaskIndex`) が容易に崩れるため。
     2. **AppleDouble ファイルの干渉**: ファイル走査を伴うロジックにおいて、隠しメタデータ `._*` が予期せぬ要素として検出され、インデックス計算を狂わせることがある。
 - **解決策**:
     1. **ライブラリの導入 (推奨)**: `@dnd-kit/core`, `@dnd-kit/sortable` 等の堅牢なライブラリに移行し、ポインターイベントベースの管理へ切り替える（UXの大幅な向上）。
     2. **ステートの唯一化**: `reorderChecklist` などのリデューサー側で、`arrayMove` 相当のロジック（スプライスと再配布）を厳格に適用し、UI側ではインデックスではなく `id` 基準でドロップ先を特定する。
 
 ### ドラッグ＆ドロップの動作が重い
 - **事象**: 並び替え操作中にカクつきが発生したり、反応が遅く感じられる。
 - **原因**: 
     1. **過度な再レンダリング**: リストアイテムが複雑な場合、マウス移動ごとに全アイテムが再計算されている。
     2. **センサー設定の不在**: デフォルトのセンサーでは微小な動きに敏感に反応しすぎ、意図しないドラッグ開始が負荷を生む。
 - **解決策**:
     1. **activationConstraint の設定**: `PointerSensor` に `distance: 8` 程度の制約を設けることで、意図的なドラッグのみをトリガーにする。
     2. **コンポーネントのメモ化**: `SortableChecklistItemRow` を `React.memo` で包み、Props が変わらない限り再描画を抑止する。
      3. **Debounced Auto-save**: 状態変更（並べ替え）ごとに即座にディスクへ書き込むのではなく、1秒程度の遊び（debounce）を設けることで、I/O 待ちによるメインスレッドのブロックを回避する。
      4. **注意点 (現状の課題)**: 2026-01-29 のユーザーフィードバックにおいて、I/O 最適化後も「あまり軽くなっていない」との報告あり。
         - **仮説**: I/O 以外の React のレンダリング負荷（特に要素数が多い場合の `DndContext` / `SortableContext` の再計算）が主要因。
         - **今後のロードマップ**: `React.memo` の更なる徹底、`PointerSensor` の `activationConstraint` 調整に加え、リストアイテムの `Virtualization` (仮想リスト) の導入を検討する必要がある。

---

## Work BGM (YouTube IFrame) の問題

### プレーヤーが表示されない / 動かない
- **事象**: BGM プレーヤーのウィジェットは表示されるが、再生ボタンを押しても音が鳴らない、またはウィジェット自体が真っ白になる。
- **原因**: 
    1. **ネットワーク制限 (CSP ブロック)**: YouTube (google.com) へアクセスが遮断されている環境、あるいは WebView の CSP (Content Security Policy) で `frame-src` や `script-src` が許可されていない。**Tauri のデフォルト設定では `csp: null` になっていることがあり、この状態では外部の IFrame やスクリプトの読み込みが暗黙的に制限される。**
    2. **Autoplay 制限**: ページロード直後にプログラムから再生を開始しようとした場合、ブラウザポリシーによりブロックされる。
    3. **背景タスクの抑制 (Background Throttling)**: IFrame が 0x0 サイズ、あるいは `display: none` / `opacity: 0` の場合、ブラウザの最適化機能によりメディア再生やネットワーク通信が停止される。
    4. **初期化タイミングの不整合**: IFrame のロード完了前に `postMessage` で再生コマンドを送ってしまうと、コマンドが無視され無音になる。
    5. **オリジン不整合 (Tauri 固有)**: Tauri の `window.location.origin` が `tauri://localhost` などのカスタムスキームである場合、YouTube API の `origin` パラメータにそのまま渡すと「プロトコル不整合」や「オリジン無効（Error 150）」として YouTube 側から制御が拒否される。
- **解決策**:
    1. **1x1 ピクセル IFrame の採用**: IFrame を完全に隠すのではなく、`width: 1px; height: 1px; opacity: 0.01;` に設定して「可視状態」を保ち、OS によるバックグラウンド抑制を確実に回避する。
    2. **react-player ライブラリへの移行 (推奨)**: 手動での `<iframe>` 制御や公式 `YT.Player` SDK は、Tauri 等の特殊な WebView 環境におけるオリジンチェックやセキュリティヘッダーの制約に極めて敏感である。`react-player` はこれらを高度に抽象化しており、単一の `url` Prop で安定した再生を実現できる。
    3. **Standard Clean Embed への検討**: 過度に複雑な `referrerPolicy` や `origin` パラメータの指定は、逆に YouTube 側の認可エラー（Heartbeat 401）を招く恐れがある。まずは公式の共有コードに準拠したパラメータから開始し、問題があれば IFrame 制御を捨てて `react-player` に移行する。
    4. **CSP の採用**: `index.html` の `Content-Security-Policy` で `frame-src https://www.youtube.com` を明示的に許可する。
    5. **Audio Diagnostics (診断モード) の活用**: 画面上の診断用オーバーレイ（REACT PLAYER MODE）を確認し、内部イベント（`onReady`, `onPlay`, `onError`）が発火しているかを確認する。
        - **Heartbeat 401 Unauthorized**: ブラウザコンソールで `youtubei/v1/player/heartbeat` が 401 エラーになる場合、IFrame 自体はロードされていても、ストリームの認可が降りていない。これはオリジンパラメータの不整合や、自動再生ポリシーへの短時間での複数回アクセスによって YouTube 側から一時的にブロックされている可能性がある。
        - **ERROR Code 101 / 150**: 「埋め込み不可」または「オリジン制限」エラー。動画自体が YouTube 側で埋め込み禁止になっていないか確認した上で、`ReactPlayer` の導入を検討。
        - **ERROR Code 100**: 動画が見つからない。Video ID が変更されていないか確認。
        - **ERROR Code 2 / 5**: 無効なパラメータまたは HTML5 プレーヤーのエラー。
        - **Error Code 39**: コンテンツ非対応または接続エラー（主に Android 等で報告されるが、Tauri ではオリジン偽装の副作用として発生する）。`origin` パラメータを削除し、デフォルト挙動に戻すことで解消するケースが多い。
    6. **TypeScript `playerVars` ビルドエラー (`Object literal may only specify known properties`)**: 
        - **事象**: `ReactPlayer` の `config.youtube` 内に `playerVars` を記述すると、`TSC` (TypeScript Compiler) が「既知のプロパティではありません」というエラーを出し、ビルドが失敗する。
        - **解決策**: `playerVars: { ... } as any` のようにキャストするか、`global.d.ts` で型定義を拡張する。
    7. **ビデオストリームのブロック (再生マークが出るが進まない)**:
        - **事象**: プレイヤーの UI は読み込まれ、再生ボタンを押すと一時停止マーク（再生中）に切り替わるが、シークバーが進まず音も出ない。
        - **原因**: CSP (Content Security Policy) で `https://*.googlevideo.com` が許可されていないため。YouTube の IFrame は読み込めても、実際の動画データ（ストリーム）を取得する際にセキュリティエラーでブロックされている。
        - **解決策**: `tauri.conf.json` の `security.csp` において、`connect-src` および `media-src` に `https://*.googlevideo.com` を追加する。また、メディアプレーヤーの種類によっては `blob:` や `mediastream:` の許可も必要になる。
        - **CSP 指定例**: `media-src 'self' blob: mediastream: https://*.googlevideo.com;`
    8. **特定プロトコル（tauri://）の拒否**:
        - **事象**: CSP を修正し、純正再生ボタンを直接押しても、特定の動画が「エラー」で止まる、あるいは再生が開始されない。
        - **原因**: YouTube IFrame は `tauri://localhost` というカスタムプロトコルからのアクセスをセキュリティ上の理由（または Safari ITP 制限）で拒否することがある。
        - **解決策**: `tauri-plugin-localhost` を導入し、アプリケーション全体を `http://localhost:port` で提供するように構成を変更する（これにより YouTube 側から見て正当な HTTP オリジンとして認識されるようになる）。
    9. **オーディオサブシステムの全停止 (HTML5 Audio 診断)**:
        - **事象**: 標準の `<audio>` タグで MP3 を再生しようとしても音が出ない。
        - **診断**: YouTube の問題ではなく、WebView または OS レベルの音声ルーティングの問題。
        - **解決策**: macOS の「システム設定 ➔ サウンド ➔ 出力」および、Tauri の `capabilities` における制限事項（もしあれば）を再確認する。
    10. **最下層のハードウェア検証 (Web Audio API / Beep Test)**:
        - **事象**: YouTube も MP3 も鳴らず、ネットワークやプロトコルの問題か、OS 側のブロックかを切り分けたい。
        - **手法**: `window.AudioContext` (または `webkitAudioContext`) を使用して、OSC (OscillatorNode) によるサイン波（ビー音）を直接生成・再生する。
        - **重要点**: `ctx.state` が `suspended` の場合、ブラウザの自動再生ポリシーによりブロックされているため、必ずユーザー操作（クリック等）の中で `context.resume()` を呼び出す必要がある。
        - **判定**: これで音が鳴る場合はハードウェアと Webview 間のパスは正常（ポモドーロ機能が鳴る場合も同様）。これで鳴るが YouTube が鳴らない場合、原因は「自動再生の拒否（User Gesture 不足）」または「オリジン制限」の可能性が極めて高い。
    11. **自動再生ポリシー (Autoplay/Mute Rule)**:
        - **事象**: プレイヤーは「再生中」に見えるが、音だけが出ない。
        - **原因**: Tauri (Safari/Webkit/WebView2) の厳しい自動再生ポリシー。ユーザーが何らかの操作（ボタンクリック等）をしていない状態で音を鳴らそうとすると、ブラウザ側でサイレントにミュートされる。
        - **解決策**: 
            - ページロード直後に鳴らさない。
            - 再生開始を必ず `onClick` イベントなどのユーザーインタラクションに紐付ける。
            - YouTube IFrame API の `origin` パラメータが現在のオリジンと完全に一致しているか再確認する（Localhost Plugin 使用時は `http://localhost:port`）。
    12. **HTMLMediaElement vs AudioContext (究極の回避策)**:
        - **事象**: Localhost Plugin を使い、CSP も許可し、ユーザーが手動で再生ボタンを押しても YouTube (IFrame) や `<audio>` タグからの音が鳴らないが、Web Audio API (`AudioContext`) を使ったビープ音やポモドーロ音は鳴る。
        - **原因**: 一部の WebView 環境において、標準のメディア要素のアウトライン出力が OS 側でミュートまたは制限されているが、Web Audio API 経由の音声合成・加工パスは許可されている不整合。
        - **解決策**: 
            - **MP3 Proxy/Streaming**: YouTube を諦め、直接 MP3 データを `fetch` し、`ctx.decodeAudioData()` を用いてデコード。
            - **Web Audio 経由の再生**: デコードしたバイナリを `ctx.createBufferSource()` で再生する。このパスはネットワーク・リソース読み込み（Tier 3）をバイパスし、ポモドーロ等と同じ「実機で鳴るパス」を確実に通る。
            - **結論**: IFrame による「ブラックボックス再生」ではなく、アプリ側でバイナリを制御する「透明な再生」へ切り替えることで、WebView の不透明な制限を突破できる。

    13. **究極の解決策: 機能の完全削除 (Feature Removal)**:
        - **事象**: これらすべての対策を講じても、外部サービスの仕様変更や WebView の暗黙的な制限により、オーディオ再生の安定性を 100% 保証することが困難であり、コードベースの肥大化が本来の「ポータブルな作業環境」という目的を阻害する。
        - **決定**: 2026-01-30、BGM プレイヤー機能（および関連する Zustand ステート、コンポーネント、複雑な CSP 設定）を完全に削除。
        - **教訓**: 「あれば便利」な機能が、プラットフォーム（Tauri/WebView）の制約と戦うための「技術的負債」の源泉になる場合、潔く削除することが、プロダクト全体の信頼性とメンテナンス性を維持するための最も賢明なエンジニアリング判断となる。

---

## ファイルシステム & I/O エラー

### 問題: エラーコード -36 (macOS 固有)
- **事象**: `“portable-studio”内の一部のデータを読み込めないか書き込めないため、操作を完了できません。（エラーコード-36）` というダイアログが出る。
- **原因**: ExFAT 上の AppleDouble ファイル (`._*`) が破損しているか、ファイルシステム上のメタデータ属性 (Finder Information) が不整合を起こしている。
- **解決策**: `dot_clean` コマンドを使用してディレクトリを修復する。
    ```bash
    dot_clean -m --keep=dotbar "/Volumes/PortableSSD/STUDIO/Apps/portable-studio"
    ```
- **注意**: これを実行しても解消しない場合は、SSD の物理的な接続不良や、他のプロセスによるポート 1420 の掴み放し (Zombie process) を疑う。

---

## AI エージェントによる自動編集の失敗

### 問題: コードの偶発的な削除 (Missing Function Signature)
- **事象**: `replace_file_content` などのツールを用いた編集後、アプリが構文エラー（`ReferenceError: get is not defined` 等）で動かなくなる。
- **原因**: エージェントが提供する `TargetContent` の範囲が広すぎたり、置換後の `ReplacementContent` で関数定義の 1 行目（例: `updateCurrentProject: async () => {`）を誤って上書き・欠落させてしまうため。これにより、関数内部のロジックがトップレベルに露出したり、変数のスコープが壊れたりする。

### 解決策
1. **最小限のチャンク化**: 一度に大きなブロックを置換するのではなく、変更が必要な行に絞って `ReplacementChunks` を作成する。
2. **編集後の構造検証**: 編集直後に `view_file` で該当箇所を読み戻し、関数の括弧 `}` やシグネチャが正しく維持されているか目視で（あるいは Lint エラーを介して）確認する。
3. **get/set の明示的再取得**: Store 内のロジックを修復する際は、必ず `const { ... } = get();` が関数の先頭に存在することを確認する。

 ---
 
 ---
 
 ## 開発サーバー & ネットワーク
 
 ### 問題: Port 1420 is already in use
 - **事象**: `pnpm tauri dev` 実行時に `Error: Port 1420 is already in use` というエラーで Vite サーバーの起動に失敗する。
 - **原因**: 以前の `tauri dev` プロセスが正常に終了しておらず、ポートが解放されていない、またはブラウザの Mock Mode 検証等でポートが占有されている。
 - **解決策**:
     1. ポート 1420 を使用しているプロセスを特定し、終了させる。
        ```bash
        lsof -i :1420
        kill -9 <PID>
        ```
     2. または、ブラウザの再読込により Mock Mode の接続を一時的にリセットする。

 ---

 ## アプリの状態管理とライフサイクル

 ### テーマ切り替え時に画面がリセットされ、音楽が止まる [解決済み]
 - **事象**: ダークモード/ライトモードを切り替えると、表示されていた Workspace が Check-in 画面（ホーム）に戻ってしまい、再生中の BGM も停止する。
 - **原因**: `App.tsx` 内のひとつの `useEffect` が `theme` と `initialize()` 両方に依存していたため。テーマ変更時に `initialize()` が再実行され、`isLoading: true` がセットされることで画面全体がアンマウントされていた。
 - **解決策**: 
    1. **Effect の分離**: テーマ適用の `useEffect` と、アプリ初期化の `useEffect` を個別のフックに分離した。
    2. これにより、テーマ変更時は `initialize()` をスキップし、CSS 属性の更新のみが行われるようになった。
    3. 同様の「トリーガーの分離」は、複雑なコンポーネントにおける再レンダリング最適化の標準パターンとして採用。

 ### 多重起動によるデータ競合の防止 (Single Instance Lock)
 - **事象**: アプリを複数立ち上げてしまい、別々のプロジェクトを操作すると、SSD 上の `data.json` が上書きし合ってデータが消失するリスクがある。
 - **解決策**: `tauri-plugin-single-instance` を導入し、OS レベルでアプリの起動を 1 インスタンスに制限する。
    1. `Cargo.toml` に依存関係を追加。
    2. `lib.rs` の `tauri::Builder` にプラグインを登録し、二重起動検知時にメインウィンドウを `set_focus()` する。
 ### コード変更が画面に反映されない (Ghost UI / Caching)
 - **事象**: `setScreen('checkout')` を削除したはずなのに、ボタンを押すと古い CheckOut ページへ遷移してしまう、あるいは削除したはずのコンポーネントが生き残っているように見える。
 - **原因**: 
    1. **Vite サーバーのキャッシュ**: `node_modules/.vite` やブラウザキャッシュに古いバンドルが残っており、HMR (Hot Module Replacement) が正しく追従できていない。
    2. **残存プロセス**: `tauri dev` がバックグラウンドで生き残っており、新しい起動プロセスとポート競合を起こしているか、古いバイナリが実行されている。
 - **解決策**:
    1. **プロセスの完全終了**: `lsof -t -i:1420 | xargs kill -9` を実行し、ポート 1420 を占有している Vite プロセスを強制終了する。
    2. **ビルドキャッシュの強制パージ**: `rm -rf node_modules/.vite` を実行し、Vite の最適化キャッシュを削除する。
    3. **クリーン起動**: `CARGO_TARGET_DIR=/tmp/portable-studio-target pnpm tauri dev` のように、ターゲットディレクトリを明示的に指定して再起動する。
    4. **不要ファイルの物理削除**: 不要になった `.ts/tsx` ファイルは、コード内の参照を消すだけでなく物理的に削除し、エディタやビルドエンジンのインデックスから除外する。

 ### コンポーネント内部のヘルパー関数による予期せぬ遷移
 - **事象**: JSX 内の `onClick` イベントをすべて更新したにもかかわらず、ショートカットキーや特定のボタン（例: 「一時離脱」など）を押すと古いページ（非存在）へ遷移しようとする。
 - **原因**: JSX 内のインライン `onClick` だけでなく、コンポーネント内に定義されたヘルパー関数（例: `handleCheckout`, `handleComplete`）の中に古い `setScreen('checkout')` ロジックが残っていたため。エージェントが「ボタンだけ」を書き換えて、内部ロジックの修正を漏らすことで発生する典型的な「中途半端なリファクタリング」の例。
 - **解決策**: 状態定義 (`screen` ➔ `modalMode`) を変更する際は、その状態を参照・更新している**すべての箇所**（ヘルパー関数、キーボードイベントハンドラ、useEffect 内の遷移ロジック等）を `grep` で徹底的に洗い出す。

 ### モーダルの状態定義不足 (Union Type Mismatch)
 - **事象**: 改修中、`setCheckoutMode('terminate')` を実行しようとすると TypeScript エラーやランタイムの挙動不整合が発生する。
 - **原因**: `CheckOutModal` の `mode` プロパティや `Workspace` 側の `useState` において、`mode` の型定義が当初 `'checkout' | 'complete'` のみに限定されており、後から追加した `'terminate'` が考慮されていなかったため。
 - **解決策**: モーダル化のような大規模なリファクタリングでは、要件定義に含まれるすべての離脱パターン（一時離脱、完了、削除）を最初から型定義に含めるか、拡張性に配慮した構造にする。

 ### 大規模削除による構成破壊 (Premature Component Closure)
 - **事象**: 不要な関数（例: 旧 `handleTerminate`）を削除した後、無関係な変数（例: `currentProject`）が「見つかりません (Undefined)」というエラーになり、コンポーネント全体が崩壊する。
 - **原因**: コード削除時に、誤ってコンポーネント関数自体の閉じ括弧 `}` を削除してしまったり、逆に余分な `}` を残してしまったため。これにより、本来関数内にあるべき `return ( ... )` ブロックが関数の外側に押し出され、スコープが壊れる。
 - **解決策**: 大規模な削除を行う際は、関数の開始・終了のペアを常に意識する。特に `Workspace.tsx` のような 1000 行単位のファイルでは、エディタのシンボルジャンプや、削除直後の `view_file` による末尾構造の再確認が必須。

 ### 編集ミスによる重複 `return` ステートメント (Duplicate Return Statements)
 - **事象**: `replace_file_content` による大規模置換の後、`式が必要です (Expression expected)` という TypeScript エラーが発生し、コンポーネントが機能しなくなる。
 - **原因**: エージェントが置換チャンクを作成する際、既存の `return (` 行を `TargetContent` に含めつつ、`ReplacementContent` の先頭にも `return (` を重複して記述してしまったため。
 - **解決策**: エージェントは編集直後に必ず `view_file` で `return` 文周辺の構文を確認し、二重になっていないか確認する。手動で修正する場合は、不要な方の `return (` 行を一行削除する。

 ### UI 移行時の「幽霊」ボタン (Redundant UI Mirroring)
 - **事象**: 新しいボタン（例: ヘッダー内）を追加したのに、以前の古いボタン（例: 画面下部）が生き残っており、古いロジックや古いステートを参照してバグを引き起こす。
 - **原因**: 新旧の UI を一時的に共存させた後、古い UI ブロックの削除を忘れてしまう「中途半端なリファクタリング」の状態。
 - **解決策**: UI を一新する際は、ステートのフロー（Trigger -> Handlers -> UI）が単一であることを確認する。新しい UI が正常に動作することを確認したら、即座に古い関連コード（JSX ブロックだけでなく、それ専用に使っていた `useState` や `handleFoo` 関数）を `grep` 等で一掃する。

 ### 子コンポーネントの Props 定義不整合 (Subcomponent Prop Mismatch)
 - **事象**: 親コンポーネントのリファクタリング（例：`index` ではなく `id` を使う、不要な `props` を消す等）を行った際、子コンポーネント呼び出し箇所で TS エラーが発生し、ビルドできなくなる。
 - **原因**: 子コンポーネントの定義を修正したのみで、親コンポーネント側の JSX タグ (`<SubComponent index={index} />`) 内の属性（Props）を更新し忘れているため。コンポーネントが 1000 行を超えると、定義位置と使用位置が離れているため見落としが発生しやすい。
 - **解決策**: 子コンポーネントの引数や `interface` を変更した際は、必ずプロジェクト全体を `grep` もしくはエディタのシンボル参照で検索し、**すべての使用箇所（JSXタグ）**を新しい定義にアラインさせる。

  ### 分割代入の「ゴースト」変数 (Lingering Unused Destructuring)
 - **事象**: ロジックを他のコンポーネントやモーダルへ移動した後、元いたコンポーネントで大量の `is defined but never used` 警告が発生し、コードの意図が不透明になる。
 - **原因**: ストアからデストラクトした関数 (`const { deleteProject } = useAppStore()`) や、ローカルステート (`isCheckingOut`) が UI から削除された後、宣言部分が残存したままになっている「リファクタリングの削り滓」。
 - **解決策**: 機能の移動が完了したら、コンポーネントの先頭に戻り、使用されなくなった変数を一括削除する。特にストアから取得しているメソッドは、不要な購読（Subscription）を避けるためにも、使わなくなった瞬間に削除することが望ましい。

 ### 翻訳漏れの「KPI Goals」表記
 - **事象**: アプリケーションを日本語化したつもりでも、一部のラベル（例: `KPI Goals`）が英語のまま残ってしまう。
 - **原因**: 大規模な JSX の中でハードコードされた文字列が目視で見落とされたため。
 - **解決策**: 表示文字列を修正する際は、エディタの検索機能で `Goal` や `Project` などのキーワードを全検索し、UI 上のすべての英語表記を「KPI目標」等の日本語に統一する。

 ### スタイル定義漏れによる未デザイン UI (Unstyled UI Components)
 - **事象**: `workspace-header-btn` などのクラス名に変更した際、ボタンがデフォルト（あるいはスタイルなし）で表示され、意図したデザインが入っていない。
 - **原因**: JSX 側でクラス名を指定したが、対応する CSS 定義を `App.css` 等に追加し忘れた、あるいはビルドキャッシュにより CSS の更新が追従していないため。
 - **解決策**: `App.css` を開き、対象となるクラス名（`.workspace-header-btn` 等）の定義があるか確認する。存在しない場合は、既存の CSS 変数（`--card-bg`, `--accent` 等）を活用して定義を追記する。定義があるのに反映されない場合は、Vite のキャッシュパージ（`rm -rf node_modules/.vite`）を実行する。

 ### 親コンテナ欠落によるレイアウト崩れ (Layout Collapse due to Missing Container)
 - **事象**: コンポーネントのリファクタリング（例: インラインスタイルからクラスへの移行や、ボタンの配置変更）を行った際、ボタンのサイズがバラバラになったり、横一列に並ばず縦に積み重なったりする。
 - **原因**: ボタン自体にスタイルが当たっていても、それらを整列させるための**親コンテナ (Flexbox 等)** の定義が漏れているため。特に「ヘッダー」から「フッター」などへ要素を移動させた際、移動先で適切なラッパー (`display: flex; gap: 1rem;`) を構築し忘れると、要素がデフォルトのブロック挙動に戻ってしまう。
 - **解決策**: 複数のアクションボタンを配置する際は、必ず `div` 等でラップし、`display: flex`, `align-items: center`, `gap` などのレイアウトプロパティを明示的に指定する。
